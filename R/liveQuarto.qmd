---
title: "Kester Weather Station"
subtitle: "Pulling Live Data"
author: "Grant and Neil Kester"
date: "24 February 2024"
theme: 
  - flatly
execute: 
  echo: true
format: 
  html:
    code-fold: true
    code-summary: "Show the code"
    embed-resources: false
    echo: true
    code-tools: 
      source: https://github.com/nkester/Kester-Weather-Visualization-Site
    page-layout: full
    output-file: "live"
    output-ext: "html"
---

version: 0.1.3 : Add a sixty day data option.

In this version of the web-page, we are pulling live data from our Google Cloud Functions.


# Charting

Currently this data is set to the last seven days of measurements. In the future, we will allow users to select which time scale and aggregation they desire.



```{ojs inputs}
//| echo: false
//| panel: sidebar

viewof measure_scale = Inputs.select([
"Select One",
"Seven days, no aggregation",
"Fourteen days, no aggregation",
"Sixty days, no aggregation"
],
{label: "Select a time scale"})


viewof measure_type = Inputs.select([
"Air Temperature",
"Air Humidity",
"Barometric Pressure",
"Light Intensity",
"Rain Gauge",
"UV Index",
"Wind"], 
{label: "Select a measure"})

viewof original_data = Inputs.checkbox(["Yes"],{label: "Include original data in chart?"})

// https://observablehq.com/@mbostock/wait-until-button
viewof action_sendquery = html`<form>${Object.assign(html`<button type=button>Draw Charts`, {onclick: event => event.currentTarget.dispatchEvent(new CustomEvent("input", {bubbles: true}))})}`
```




:::{.panel-tabset}  

## Plot

```{ojs}


chart = {
  replay;
  const nonlinegraph_measures = ["Wind"]
  if(!nonlinegraph_measures.includes(measure_type))
  {
    if(original_data.includes("Yes")){
    
      return drawchart(aggregatedData, filteredData)
      
    }else{
    
      return drawchart(aggregatedData)
      
    }
  }else{
  
    return vector(filteredData)
    
  };

}


```  

```{ojs}
viewof replay = Inputs.button("Replay")
```



## OJS Table

Filtered Data Table  

```{ojs}
Inputs.table(filteredData)
```  

Combined Data

```{ojs}
Inputs.table(aggregatedData)
```

## New Chart


Aggregated First with `As Measured`  

```{ojs}
chart_old = {
  replay;
  return drawchart(aggregatedData, filteredData);

}
```  

Then only `As Measured` by itself

```{ojs}
chart2 = {
  replay;
  return drawchart(filteredData);

}
```

```{ojs}
Plot.line(aggregatedData, {x: "time",y:"measurementValue",marker:false,curve:"natural"}).plot({grid:true})
```

```{ojs}
length = (path) => d3.create("svg:path").attr("d", path).node().getTotalLength()
```

Original Plots

```{ojs}
Plot.dot(filteredData,
  {
    x: "time",
    y: "measurementValue", 
    stroke: "measurementValue",
    tip: true
  })
  .plot()
```


The plot as a line graph.


```{ojs}
Plot.plot({
  marks: [
    Plot.line(filteredData, 
      {
        x: "time",
        y: "measurementValue"
      })
    ]
})
```

:::



## Appendix

Find the source code on GitHub at [Kester Weather Visualization Site](https://github.com/nkester/Kester-Weather-Visualization-Site)


```{ojs imports}

import { aq, op } from '@uwdata/arquero'
d3 = require("d3@7")
parser = d3.timeParse("%Y-%m-%d %H:%M:%S%Z");
```

```{ojs filterData}

// Arquero is an ojs package for data manipulation similar to dplyr. I import it
//  above as well in the `imports` chunk. I use arquero (`aq`) to convert the 
//  data returned by the cloud function from a string to a datetime object.
//  I've defined the date parser with `D3`, another `ojs` package. An example
//  of that is here: https://stackoverflow.com/questions/76499928/passing-dates-from-r-chunk-to-ojs-chunk-using-ojs-define-in-quarto  
//  
// https://quarto.org/docs/interactive/ojs/examples/arquero.html
 measures = {
 action_sendquery;
  if (measure_scale === "Seven days, no aggregation"){
    return(await d3.json("https://us-east1-weather-station-ef6ca.cloudfunctions.net/https_measure_7day_asis"))
  }
  else if (measure_scale === "Fourteen days, no aggregation"){
    return(await d3.json("https://us-east1-weather-station-ef6ca.cloudfunctions.net/https_measure_14day_asis"))
  }
  else if (measure_scale === "Sixty days, no aggregation"){
    return(await d3.json("https://us-east1-weather-station-ef6ca.cloudfunctions.net/https_measure_60day_asis"))
  }
  else{
    return(JSON.parse('[{"local_time":"1000-02-02 11:11:11","type": "test","measurementValue":"49"}]'))
  }
}
 
// Take the full dataset and filter out to only the measures the user selects.
filteredData = {
  if(measure_type === "Wind"){
    return aq.from(measures)
      .derive({ time: aq.escape(d => parser(d.local_time)) })
      .params({
        m: "Wind Direction Sensor",
        n: "Wind Speed"
      })
      .filter((d,p) => aq.op.includes(d.type, p.m) || aq.op.includes(d.type, p.n))
      .orderby( 'time')
      
  }else{
    return aq.from(measures)
        .derive({ time: aq.escape(d => parser(d.local_time)) })
        .params({
          m: measure_type
        })
        .filter((d,p) => aq.op.includes(d.type, p.m))
        .orderby( 'time')
        
        
  }
}
// If the user wants an aggregation, complete that aggregation on the filtered data.
aggregatedData = filteredData
  .derive({ 'measurementValue': aq.rolling(d => aq.op.sum(d.measurementValue), [-96, 0]) })

```

### Functions

```{ojs}
// https://observablehq.com/@d3/connected-scatterplot/2?intent=fork
//| echo: false
function drawchart(dat, dat2){

  const width = 928;
  const height = 720;
  const marginTop = 20;
  const marginRight = 30;
  const marginBottom = 30;
  const marginLeft = 40;
  
  // Declare the positional encodings.
  const x = d3.scaleTime()
      .domain(d3.extent(dat, d => d.time))
      .range([marginLeft, width - marginRight]);
      
  const y = d3.scaleLinear()
      .domain(d3.extent(dat, d => d.measurementValue)).nice()
      .range([height - marginBottom, marginTop]);
      
  const line = d3.line()
      .curve(d3.curveCatmullRom)
      .x(d => x(d.time))
      .y(d => y(d.measurementValue));
      
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr("style", "max-width: 100%; height: auto;");
      
  const l = length(line(dat));
  
  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(d3.axisBottom(x).ticks(d3.timeDay))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").clone()
          .attr("y2", -height)
          .attr("stroke-opacity", 0.1))
      .call(g => g.append("text")
          .attr("x", width - 4)
          .attr("y", -4)
          .attr("font-weight", "bold")
          .attr("text-anchor", "end")
          .attr("fill", "currentColor")
          .text("Date"));
          
  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(d3.axisLeft(y).ticks(null, ".2f"))
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").clone()
          .attr("x2", -width)
          .attr("stroke-opacity", 0.1))
      .call(g => g.append("text")
          .attr("x", 10)
          .attr("y", height - 4)
          .attr("text-anchor", "start")
          .attr("font-weight", "bold")
          .text("Measure"));
          
  svg.append("path")
      .datum(dat)
      .attr("fill", "none")
      .attr("stroke", "blue")
      .attr("stroke-width", 2.5)
      .attr("stroke-linejoin", "round")
      .attr("stroke-linecap", "round")
      .attr("stroke-dasharray", `0,${l}`)
      .attr("d", line)
    .transition()
      .duration(5000)
      .ease(d3.easeLinear)
      .attr("stroke-dasharray", `${l},${l}`);
      
      if (typeof dat2 !== 'undefined'){
      
         svg.append("path")
           .datum(dat2)
           .attr("fill", "none")
           .attr("stroke", "red")
           .attr("stroke-width", 2.5)
           .attr("stroke-linejoin", "round")
           .attr("stroke-linecap", "round")
           .attr("stroke-dasharray", `0,${l}`)
           .attr("d", line)
         .transition()
           .duration(5000)
           .ease(d3.easeLinear)
           .attr("stroke-dasharray", `${l},${l}`);
      };

  return svg.node();

}

```

```{ojs}
// https://observablehq.com/@d3/radial-stacked-bar-chart/2
// https://observablehq.com/@d3/radial-area-chart/2

function vector(dat){

  const direction = dat
                   .filter(d => aq.op.includes(d.type, "Wind Direction Sensor"))
                   .orderby( 'time')

  const speed = dat
                     .filter(d => aq.op.includes(d.type, "Wind Speed"))
                     .orderby( 'time')
  

  
  const width = 928;
  const height = width;
  const margin = 10;
  const innerRadius = width / 5;
  const outerRadius = width / 2 - margin;
  
  const x = d3.scaleUtc()
    .domain([d3.min(dat, d => d.time),d3.max(dat, d => d.time)])
    .range([0, 2 * Math.PI]);
    
  const y = d3.scaleRadial()
    .domain([d3.min(speed, d => d.measurementValue), d3.max(speed, d => d.measurementValue)])
    .range([innerRadius, outerRadius]);
    
  const line = d3.lineRadial()
    .curve(d3.curveLinearClosed)
    .angle(d => x(d.time));
    
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [-width / 2, -height / 2, width, height])
      .attr("style", "width: 100%; height: auto; font: 10px sans-serif;")
      .attr("stroke-linejoin", "round")
      .attr("stroke-linecap", "round");
      
  svg.append("path")
      .attr("fill", "none")
      .attr("stroke", "steelblue")
      .attr("stroke-width", 1.5)
      .attr("d", line
          .radius(d => y(d.measurementValue))
          (speed));
          
  svg.append("g")
    .selectAll()
    .data(x.ticks())
    .join("g")
      .each((d, i) => d.id = DOM.uid("month"))
      .call(g => g.append("path")
        .attr("strok", "#000")
        .attr("stroke-opacity", 0.2)
        .attr("d", d => `
          M${d3.pointRadial(x(d), innerRadius)}
          L${d3.pointRadial(x(d), outerRadius)}
          `))
      .call(g => g.append("path")
          .attr("id", d => d.id.id)
          .datum(d => [d, d3.utcMonth.offset(d, 1)])
          .attr("fill", "none")
          .attr("d", ([a, b]) => `
            M${d3.pointRadial(x(a), innerRadius)}
            A${innerRadius},${innerRadius} 0,0,1 ${d3.pointRadial(x(b), innerRadius)}
            `))
        .call(g => g.append("text")
          .append("textPath")
            .attr("startOffset", 6)
            .attr("xlink:href", d => d.id.href)
            .text(d3.utcFormat("%Y")));
            
  svg.append("g")
      .attr("text-anchor", "middle")
    .selectAll()
    .data(y.ticks().reverse())
    .join("g")
      .call(g => g.append("circle")
        .attr("fill", "none")
        .attr("stroke", "currentColor")
        .attr("stroke-opacity", 0.2)
        .attr("r", y))
      .call(g => g.append("text")
        .attr("y", d => -y(d))
        .attr("dy", "0.35em")
        .attr("stroke", "#fff")
        .attr("stroke-width", 5)
        .attr("fill", "currentColor")
        .attr("paint-order", "stroke")
        .text((x, i) => `${x.toFixed(0)}${i ? "" : "km/hr"}`)
      .clone(true)
        .attr("y", d => y(d)));
          

  return svg.node();

}
```
Reference for a vector graph for wind speed and direction
https://observablehq.com/@d3/vector-field

[Personal Website](https://www.about.nkester.com)





```{ojs}
// https://observablehq.com/@uwdata/an-illustrated-guide-to-arquero-verbs#filter
// this should move up to the previous block but will stay here until the chart
//  is figured out.
// https://observablehq.com/@uwdata/introducing-arquero
wind = {

const windtable = aq.from(filteredData)
                      .groupby('time')
                      .pivot('type','measurementValue')
                      .rename({ 'Wind Direction Sensor': 'direction', 'Wind Speed': 'speed'})
                      .join_full(aq.table({
                                     direction: Array(361)
                                       .fill()
                                       .map((element, index) => index),
                                     speed: Array(361)
                                       .fill(0)}))
                      .groupby('direction')
                      .rollup({
                          avg: d => aq.op.average(d.speed), 
                          min: d => aq.op.min(d.speed), 
                          max: d => aq.op.max(d.speed)})
                      .orderby('direction')

return windtable

}
```

```{ojs}
Inputs.table(wind)
```

```{ojs}
function vector_test(dat){
  const width = 928;
  const height = width;
  const margin = 10;
  const innerRadius = width / 10;
  const outerRadius = width / 2 - margin;
  
  const x = d3.scaleLinear()
    .domain([d3.min(dat, d => d.direction),d3.max(dat, d => d.direction)])
    .range([0, 2 * Math.PI]); //[d3.min(dat, d => d.direction),d3.max(dat, d => d.direction)]);
    
  const y = d3.scaleRadial()
    .domain([d3.min(dat, d => d.min), d3.max(dat, d => d.max)])
    .range([innerRadius, outerRadius]);
    
  const line = d3.lineRadial()
    .curve(d3.curveLinearClosed)
    .angle(d => x(d.direction));
    
  const area = d3.areaRadial()
    .curve(d3.curveLinearClosed)
    .angle(d => x(d.direction));
    
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [-width / 2, -height / 2, width, height])
      .attr("style", "width: 100%; height: auto; font: 10px sans-serif;")
      .attr("stroke-linejoin", "round")
      .attr("stroke-linecap", "round");
      
  svg.append("path")
      .attr("fill", "lightsteelblue")
      .attr("fill-opacity", 0.2)
      .attr("d", area
            .innerRadius(d => y(d.min))
            .outerRadius(d => y(d.max))
            (dat));
      
  svg.append("path")
      .attr("fill", "none")
      .attr("stroke", "steelblue")
      .attr("stroke-width", 1.5)
      .attr("d", line
          .radius(d => y(d.avg))
          (dat));
          
  svg.append("g")
      .selectAll()
      .data(x.ticks())
      .join("g")
        .each((d, i) => d.id = DOM.uid("degree"))
        .call(g => g.append("path")
            .attr("stroke", "#000")
            .attr("stroke-opacity", 0.2)
            .attr("d", d => `
              M${d3.pointRadial(x(d), innerRadius)}
              L${d3.pointRadial(x(d), outerRadius)}
              `))
        
  svg.append("g")
      .attr("text-anchor", "middle")
    .selectAll()
    .data(y.ticks().reverse())
    .join("g")
      .call(g => g.append("circle")
          .attr("fill", "none")
          .attr("stroke", "currentColor")
          .attr("stroke-opacity", 0.2)
          .attr("r", y))
      .call(g => g.append("text")
          .attr("y", d => -y(d))
          .attr("dy", "0.35em")
          .attr("stroke", "#fff")
          .attr("stroke-width", 5)
         .attr("fill", "currentColor")
          .attr("paint-order", "stroke")
          .text((x, i) => `${x.toFixed(0)}${i ? "": " mph"}`)
      .clone(true)
        .attr("y", d => y(d)));
  
 return svg.node();
}
          
```  

```{ojs}
vector_test(wind)
```  


```{ojs}
function linearGraph(dat){
const width = 928;
  const height = width;
  const margin = 10;
  const innerRadius = width / 10;
  const outerRadius = width / 2 - margin;
  
  const x = d3.scaleLinear()
    .domain([d3.min(dat, d => d.direction),d3.max(dat, d => d.direction)])
    .range([margin, width - margin]); //[d3.min(dat, d => d.direction),d3.max(dat, d => d.direction)]);
    
  const y = d3.scaleLinear()
    .domain([d3.min(dat, d => d.min), d3.max(dat, d => d.max)])
    .range([height - margin, margin]);
    
  const line = d3.line()
    .x(d => x(d.direction))
    .y(d => y(d.avg))
    .curve(d3.curveNatural);
    
    
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [-width / 2, -height / 2, width, height])
      .attr("style", "width: 100%; height: auto; font: 10px sans-serif;")
      .attr("stroke-linejoin", "round")
      .attr("stroke-linecap", "round");

      
  svg.append("path")
      .attr("fill", "none")
      .attr("stroke", "steelblue")
      .attr("stroke-width", 1.5)
      .attr("d", line(dat));
      
  svg.append("g")
      .attr("transform", `translate(0,${height - margin})`)
      .call(d3.axisBottom(x))
      .call(g => g.append("text")
          .attr("x", width - 4)
          .attr("y", -4)
          .attr("font-weight", "bold")
          .attr("text-anchor", "end")
          .attr("fill", "currentColor")
          .text("Date"));
  
 return svg.node();
}
```  

```{ojs}
linearGraph(wind)
```