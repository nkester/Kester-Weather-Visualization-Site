---
title: "Kester Weather Station"
author: "Grant and Neil Kester"
date: "21 November 2023"
theme: 
  - flatly
execute: 
  echo: false
format: 
  html:
    embed-resources: true
    echo: false
    code-tools: true
    page-layout: full
    output-file: "WeatherMeasurements"
    output-ext: "html"
---

version: 0.3.1

We are trying to improve our charting work with Observable JS. 

> **Update Note:** We have fixed the x-axis labels by properly converting to and dealing with date objects.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(magrittr)

local <- TRUE
update <- FALSE
```

```{r functions, include=FALSE}

# This function builds the PostgreSQL query required to aggregate the timeseries
#  data to a specified level.
agg_query <- function(agg_function, type, agg_level){
  
  sprintf("SELECT date, type, %s(\"measurementValue\") AS measure,min(\"measurementValue\") AS measure_min,max(\"measurementValue\") AS measure_max 
                 FROM (
                   SELECT date_trunc('%s',time) AS date,type,\"measurementValue\" 
                   FROM sensor_data
                   WHERE type = '%s') AS A 
                 GROUP BY date,type",agg_function,agg_level,type)
  
}

measure_gather <- function(con, measure_spec, measure_tib, agg_levels){
  
  for(measure in 1:nrow(measure_spec)){
    
    for(agg in agg_levels){
      
      print(sprintf("Measure: %s, Function: %s, and aggregation: %s",
                    measure_spec[measure,2],
                    measure_spec[measure,1],
                    agg))
      
      
      temp <- DBI::dbGetQuery(conn = con,
                              statement = agg_query(agg_function = measure_spec[measure,1],type = measure_spec[measure,2],agg_level = agg))
      
      measure_tib <- dplyr::bind_rows(measure_tib,
                                      tibble::tibble(aggregate_level = agg,
                                                     temp))
      
      
    }
    
  }
  
  return(measure_tib)
  
  
}

```  

This page displays the measurements taken from our personal weather station. The raw measurements are taken every 15 minutes but we have aggregated the information when pulling it from our `PostgreSQL` database to every hour, day, and month.  

Much improvement is required to make meaningful conclusions from the data and for them to make sense in the context of what the measurements mean.

## Get Data

Connect to the database

```{r getData, include=FALSE,eval=TRUE}
if(any(c(!local,update))){
  
  load(file = "./connectionInfo.RData")
  
  measure_spec <- tibble::tibble(fun = c('avg',
                                         'avg',
                                         'avg',
                                         'avg',
                                         'sum',
                                         'avg',
                                         'avg',
                                         'avg'),
                                 type = c('Air Humidity',
                                          'Air Temperature',
                                          'Barometric Pressure',
                                          'Light Intensity',
                                          'Rain Gauge',
                                          'UV Index',
                                          'Wind Direction Sensor',
                                          'Wind Speed'))
  
  agg_levels <- c('month','day','hour')
  
  measure_tib <- tibble::tibble(aggregate_level = "NA",
                                date = Sys.time(),
                                type = "NA",
                                measure = 1.1,
                                measure_min = 1.1,
                                measure_max = 1.1)[-1,]
  
  con <- DBI::dbConnect(drv = RPostgreSQL::PostgreSQL(),
                        dbname = db,
                        host = host,
                        port = port,
                        user = user,
                        password = password)
  
  #measure_AirHumidity_month
  
  measure_tib <- measure_gather(con = con,
                                measure_spec = measure_spec,
                                measure_tib = measure_tib,
                                agg_levels = agg_levels)
  
  DBI::dbDisconnect(conn = con)
  
  save(measure_tib,
       file = "./weatherData.RDS")
  
  rm(con,db,host,password,port,user)
}

if(all(local,file.exists("./weatherData.RDS"))){
  
  load(file = "./weatherData.RDS")
  
}

if(exists(x = "measure_tib")){
  
  ojs_define(measures = measure_tib)
  
}

```
> Add an aggregation level of "As Measured"

# Selections

```{ojs imports}
//| echo: false

import { aq, op } from '@uwdata/arquero'
d3 = require("d3@7")
parser = d3.timeParse("%Y-%m-%d %H:%M:%S");
```

```{ojs inputs}
//| echo: false
//| panel: sidebar

viewof time_aggregation = Inputs.select(["hour","day","month"], {label: "Time Aggregation"})

viewof measure_type = Inputs.select([
"Air Humidity",
"Air Temperature",
"Barometric Pressure",
"Light Intensity",
"Rain Gauge",
"UV Index",
"Wind Direction Sensor",
"Wind Speed"], 
{label: "Select a measure"})

```

:::{.panel-tabset}  

## Plot

```{ojs}
Plot.dot(filteredData,{
x: "date",
y: "measure", 
stroke: "measure",
tip: true
}).plot()
```


The plot as a line graph.

```{ojs}
Plot.plot({
  marks: [
    Plot.line(filteredData, {
      x: "date",
      y: "measure"
    })
  ]//,
//  width: 300,
//  height: 130,
//  x: { domain: [new Date("2023-09-13"), new Date("2023-11-13")], grid: true},
//  y: { ticks: 3},
//  marginLeft: 50,
//  color: {
//    legend: true,
//    width: 300,
//    columns: "120px"
//}

})
```


## OJS Table

```{ojs}
//| echo: false

// Arquero is an ojs package for data manipulation similar to dplyr. I import it
//  above as well in the `imports` chunk. I use arquero (`aq`) to convert the 
//  data passed by `R` with `ojs_define()` from text back into a date objective.
//  I've defined the date parser with `D3`, another `ojs` package. An example
//  of that is here: https://stackoverflow.com/questions/76499928/passing-dates-from-r-chunk-to-ojs-chunk-using-ojs-define-in-quarto  
//  Additionally, because R uses rectangular data but `ojs` uses array data I have
//  to transpose the data to make it useful. If not you get the `e is not iterable` error.
// 
// So that my data reacts to the input values, I filter it by using anonymous functions
//  This is often required in `ojs`. The `.params` argument allows you to pass
//  external fields (my two user inputs) into the function as elements of a variable.
//  
// https://quarto.org/docs/interactive/ojs/examples/arquero.html
measures_trans = aq.from(transpose(measures)).derive({ date: aq.escape(d => parser(d.date)) })

filteredData = measures_trans
  .params({
   m: measure_type,
   t: time_aggregation
})
  .filter((d,p) => op.includes(d.type, p.m) && op.includes(d.aggregate_level, p.t))


```


Filtered Data Table  

```{ojs}
Inputs.table(filteredData)
```

:::





