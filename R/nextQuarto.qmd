---
title: "Kester Weather Station"
author: "Grant and Neil Kester"
date: "12 November 2023"
execute: 
  echo: false
format: 
  html:
    embed-resources: true
    echo: false
    code-tools: true
    page-layout: full
    output-file: "WeatherMeasurements"
    output-ext: "html"
---

version: 0.3

We are trying to improve our charting work with Observable JS. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(magrittr)

local <- FALSE
update <- FALSE
```

```{r functions, include=FALSE}

# This function builds the PostgreSQL query required to aggregate the timeseries
#  data to a specified level.
agg_query <- function(agg_function, type, agg_level){
  
  sprintf("SELECT date, type, %s(\"measurementValue\") AS measure,min(\"measurementValue\") AS measure_min,max(\"measurementValue\") AS measure_max 
                 FROM (
                   SELECT date_trunc('%s',time) AS date,type,\"measurementValue\" 
                   FROM sensor_data
                   WHERE type = '%s') AS A 
                 GROUP BY date,type",agg_function,agg_level,type)
  
}

measure_gather <- function(con, measure_spec, measure_tib, agg_levels){
  
  for(measure in 1:nrow(measure_spec)){
    
    for(agg in agg_levels){
      
      print(sprintf("Measure: %s, Function: %s, and aggregation: %s",
                    measure_spec[measure,2],
                    measure_spec[measure,1],
                    agg))
      
      
      temp <- DBI::dbGetQuery(conn = con,
                              statement = agg_query(agg_function = measure_spec[measure,1],type = measure_spec[measure,2],agg_level = agg))
      
      measure_tib <- dplyr::bind_rows(measure_tib,
                                      tibble::tibble(aggregate_level = agg,
                                                     temp))
      
      
    }
    
  }
  
  return(measure_tib)
  
  
}

```  

This page displays the measurements taken from our personal weather station. The raw measurements are taken every 15 minutes but we have aggregated the information when pulling it from our `PostgreSQL` database to every hour, day, and month.  

Much improvement is required to make meaningful conclusions from the data and for them to make sense in the context of what the measurements mean.

## Get Data

Connect to the database

```{r getData, include=FALSE,eval=TRUE}
if(any(c(!local,update))){
  
  load(file = "./connectionInfo.RData")
  
  measure_spec <- tibble::tibble(fun = c('avg',
                                         'avg',
                                         'avg',
                                         'avg',
                                         'sum',
                                         'avg',
                                         'avg',
                                         'avg'),
                                 type = c('Air Humidity',
                                          'Air Temperature',
                                          'Barometric Pressure',
                                          'Light Intensity',
                                          'Rain Gauge',
                                          'UV Index',
                                          'Wind Direction Sensor',
                                          'Wind Speed'))
  
  agg_levels <- c('month','day','hour')
  
  measure_tib <- tibble::tibble(aggregate_level = "NA",
                                date = Sys.time(),
                                type = "NA",
                                measure = 1.1,
                                measure_min = 1.1,
                                measure_max = 1.1)[-1,]
  
  con <- DBI::dbConnect(drv = RPostgreSQL::PostgreSQL(),
                        dbname = db,
                        host = host,
                        port = port,
                        user = user,
                        password = password)
  
  #measure_AirHumidity_month
  
  measure_tib <- measure_gather(con = con,
                                measure_spec = measure_spec,
                                measure_tib = measure_tib,
                                agg_levels = agg_levels)
  
  DBI::dbDisconnect(conn = con)
  
  save(measure_tib,
       file = "./weatherData.RDS")
  
  rm(con,db,host,password,port,user)
}

if(all(local,file.exists("./weatherData.RDS"))){
  
  load(file = "./weatherData.RDS")
  
}

if(exists(x = "measure_tib")){
  
  ojs_define(measures = measure_tib)
  
}

```
> Add an aggregation level of "As Measured"

# Selections

```{ojs inputs}
//| echo: false
//| panel: sidebar

viewof time_aggregation = Inputs.select(["hour","day","month"], {label: "Time Aggregation"})

viewof measure_type = Inputs.select([
"Air Humidity",
"Air Temperature",
"Barometric Pressure",
"Light Intensity",
"Rain Gauge",
"UV Index",
"Wind Direction Sensor",
"Wind Speed"], 
{label: "Select a measure"})


```

:::{.panel-tabset}  

## Plot

```{ojs}
Plot.dot(filteredData,{
x: "date",
y: "measure", 
stroke: "measure",
tip: true
}).plot()
```

```{ojs}
Plot.plot({
marks: [
Plot.dot(filteredData, {
x: "date",
y: "measure",
stroke: "measure"
})

]

})
```

{
marks: [
Plot.ruleY([-10,50])
]
}

## OJS Table

```{ojs}
//| echo: false

measures_trans = transpose(measures)

filteredData = measures_trans.filter(function(weatherdata) {

return time_aggregation.includes(weatherdata.aggregate_level) &&
measure_type.includes(weatherdata.type)

})


```

This is the filtered data. You can also search for specific information

```{ojs}
viewof search = Inputs.search(filteredData)

Inputs.table(search)
```

:::





